{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Receipt",
  "description": "The outcome of a completed run: metadata, usage, trace, and verification.\n\nUse [`Receipt::with_hash`] to compute and attach the canonical SHA-256 hash.\n\n# Examples\n\n```\nuse abp_core::{ReceiptBuilder, Outcome};\n\nlet receipt = ReceiptBuilder::new(\"mock\")\n    .outcome(Outcome::Complete)\n    .build()\n    .with_hash()\n    .unwrap();\n\nassert!(receipt.receipt_sha256.is_some());\n```",
  "type": "object",
  "properties": {
    "artifacts": {
      "description": "References to artifacts produced during the run.",
      "type": "array",
      "items": {
        "$ref": "#/$defs/ArtifactRef"
      }
    },
    "backend": {
      "description": "Backend that executed the work order.",
      "$ref": "#/$defs/BackendIdentity"
    },
    "capabilities": {
      "description": "Capability manifest reported by the backend.",
      "type": "object",
      "additionalProperties": {
        "$ref": "#/$defs/SupportLevel"
      }
    },
    "meta": {
      "description": "Timing and identity metadata for this run.",
      "$ref": "#/$defs/RunMetadata"
    },
    "mode": {
      "description": "Execution mode used for this run.",
      "$ref": "#/$defs/ExecutionMode",
      "default": "mapped"
    },
    "outcome": {
      "description": "High-level result status.",
      "$ref": "#/$defs/Outcome"
    },
    "receipt_sha256": {
      "description": "Hash of the canonical receipt (filled in by the control plane).",
      "type": [
        "string",
        "null"
      ]
    },
    "trace": {
      "description": "Ordered log of events emitted during the run.",
      "type": "array",
      "items": {
        "$ref": "#/$defs/AgentEvent"
      }
    },
    "usage": {
      "description": "Normalized usage fields (best-effort).",
      "$ref": "#/$defs/UsageNormalized"
    },
    "usage_raw": {
      "description": "Vendor-specific usage payload as reported."
    },
    "verification": {
      "description": "Git-based verification data captured after completion.",
      "$ref": "#/$defs/VerificationReport"
    }
  },
  "required": [
    "meta",
    "backend",
    "capabilities",
    "usage_raw",
    "usage",
    "trace",
    "artifacts",
    "verification",
    "outcome"
  ],
  "$defs": {
    "AgentEvent": {
      "description": "A timestamped event emitted by an agent during a run.\n\n# Examples\n\n```\nuse abp_core::{AgentEvent, AgentEventKind};\nuse chrono::Utc;\n\nlet event = AgentEvent {\n    ts: Utc::now(),\n    kind: AgentEventKind::AssistantMessage {\n        text: \"Hello, world!\".into(),\n    },\n    ext: None,\n};\nassert!(matches!(event.kind, AgentEventKind::AssistantMessage { .. }));\n```",
      "type": "object",
      "properties": {
        "ext": {
          "description": "Extension field for passthrough mode raw data.\n\nIn passthrough mode, this contains the original SDK message\nfor lossless reconstruction. The key `raw_message` contains\nthe verbatim SDK message.",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": true
        },
        "ts": {
          "description": "Timestamp when the event was emitted.",
          "type": "string",
          "format": "date-time"
        }
      },
      "oneOf": [
        {
          "description": "The agent run has started.",
          "type": "object",
          "properties": {
            "message": {
              "description": "Human-readable start message.",
              "type": "string"
            },
            "type": {
              "type": "string",
              "const": "run_started"
            }
          },
          "required": [
            "type",
            "message"
          ]
        },
        {
          "description": "The agent run has completed.",
          "type": "object",
          "properties": {
            "message": {
              "description": "Human-readable completion message.",
              "type": "string"
            },
            "type": {
              "type": "string",
              "const": "run_completed"
            }
          },
          "required": [
            "type",
            "message"
          ]
        },
        {
          "description": "Incremental assistant text (streaming token).",
          "type": "object",
          "properties": {
            "text": {
              "description": "The text fragment.",
              "type": "string"
            },
            "type": {
              "type": "string",
              "const": "assistant_delta"
            }
          },
          "required": [
            "type",
            "text"
          ]
        },
        {
          "description": "Complete assistant message.",
          "type": "object",
          "properties": {
            "text": {
              "description": "The full message text.",
              "type": "string"
            },
            "type": {
              "type": "string",
              "const": "assistant_message"
            }
          },
          "required": [
            "type",
            "text"
          ]
        },
        {
          "description": "A tool invocation by the agent.",
          "type": "object",
          "properties": {
            "input": {
              "description": "JSON input passed to the tool."
            },
            "parent_tool_use_id": {
              "description": "Identifier of the parent tool use, if nested.",
              "type": [
                "string",
                "null"
              ]
            },
            "tool_name": {
              "description": "Name of the tool being called.",
              "type": "string"
            },
            "tool_use_id": {
              "description": "Unique identifier for this tool use.",
              "type": [
                "string",
                "null"
              ]
            },
            "type": {
              "type": "string",
              "const": "tool_call"
            }
          },
          "required": [
            "type",
            "tool_name",
            "input"
          ]
        },
        {
          "description": "Result returned from a tool invocation.",
          "type": "object",
          "properties": {
            "is_error": {
              "description": "Whether the tool reported an error.",
              "type": "boolean"
            },
            "output": {
              "description": "JSON output from the tool."
            },
            "tool_name": {
              "description": "Name of the tool that produced this result.",
              "type": "string"
            },
            "tool_use_id": {
              "description": "Identifier correlating to the originating tool call.",
              "type": [
                "string",
                "null"
              ]
            },
            "type": {
              "type": "string",
              "const": "tool_result"
            }
          },
          "required": [
            "type",
            "tool_name",
            "output",
            "is_error"
          ]
        },
        {
          "description": "A file was created or modified in the workspace.",
          "type": "object",
          "properties": {
            "path": {
              "description": "Path to the changed file (relative to workspace root).",
              "type": "string"
            },
            "summary": {
              "description": "Human-readable summary of the change.",
              "type": "string"
            },
            "type": {
              "type": "string",
              "const": "file_changed"
            }
          },
          "required": [
            "type",
            "path",
            "summary"
          ]
        },
        {
          "description": "A shell command was executed.",
          "type": "object",
          "properties": {
            "command": {
              "description": "The command that was run.",
              "type": "string"
            },
            "exit_code": {
              "description": "Process exit code, if available.",
              "type": [
                "integer",
                "null"
              ],
              "format": "int32"
            },
            "output_preview": {
              "description": "Truncated preview of the command output.",
              "type": [
                "string",
                "null"
              ]
            },
            "type": {
              "type": "string",
              "const": "command_executed"
            }
          },
          "required": [
            "type",
            "command"
          ]
        },
        {
          "description": "A non-fatal warning emitted during the run.",
          "type": "object",
          "properties": {
            "message": {
              "description": "Warning message text.",
              "type": "string"
            },
            "type": {
              "type": "string",
              "const": "warning"
            }
          },
          "required": [
            "type",
            "message"
          ]
        },
        {
          "description": "A fatal error emitted during the run.",
          "type": "object",
          "properties": {
            "error_code": {
              "description": "Machine-readable error code from the unified taxonomy, if available.",
              "anyOf": [
                {
                  "$ref": "#/$defs/ErrorCode"
                },
                {
                  "type": "null"
                }
              ]
            },
            "message": {
              "description": "Error message text.",
              "type": "string"
            },
            "type": {
              "type": "string",
              "const": "error"
            }
          },
          "required": [
            "type",
            "message"
          ]
        }
      ],
      "required": [
        "ts"
      ]
    },
    "ArtifactRef": {
      "description": "Reference to an artifact produced during a run (e.g. a patch file).",
      "type": "object",
      "properties": {
        "kind": {
          "description": "Artifact type (e.g. `\"patch\"`, `\"log\"`).",
          "type": "string"
        },
        "path": {
          "description": "Path to the artifact relative to the workspace root.",
          "type": "string"
        }
      },
      "required": [
        "kind",
        "path"
      ]
    },
    "BackendIdentity": {
      "description": "Identifies a backend and its version information.\n\n# Examples\n\n```\nuse abp_core::BackendIdentity;\n\nlet id = BackendIdentity {\n    id: \"sidecar:node\".into(),\n    backend_version: Some(\"1.0.0\".into()),\n    adapter_version: None,\n};\nassert_eq!(id.id, \"sidecar:node\");\n```",
      "type": "object",
      "properties": {
        "adapter_version": {
          "description": "Adapter version (your sidecar wrapper version).",
          "type": [
            "string",
            "null"
          ]
        },
        "backend_version": {
          "description": "Backend runtime version (SDK version, CLI version, etc.).",
          "type": [
            "string",
            "null"
          ]
        },
        "id": {
          "description": "Stable backend identifier (e.g. `\"mock\"`, `\"sidecar:node\"`).",
          "type": "string"
        }
      },
      "required": [
        "id"
      ]
    },
    "ErrorCode": {
      "description": "Machine-readable, stable error code.\n\nEach variant serialises to a `SCREAMING_SNAKE_CASE` string that is\nguaranteed not to change across patch releases.\n\n# Examples\n\n```\nuse abp_error::ErrorCode;\n\nlet code = ErrorCode::BackendTimeout;\nassert_eq!(code.as_str(), \"BACKEND_TIMEOUT\");\nassert_eq!(code.to_string(), \"BACKEND_TIMEOUT\");\nassert_eq!(code.category().to_string(), \"backend\");\n```",
      "oneOf": [
        {
          "description": "Envelope failed to parse or has missing/invalid fields.",
          "type": "string",
          "const": "PROTOCOL_INVALID_ENVELOPE"
        },
        {
          "description": "Message arrived in wrong order (e.g. event before hello).",
          "type": "string",
          "const": "PROTOCOL_UNEXPECTED_MESSAGE"
        },
        {
          "description": "Contract version mismatch between host and sidecar.",
          "type": "string",
          "const": "PROTOCOL_VERSION_MISMATCH"
        },
        {
          "description": "Requested backend name does not exist.",
          "type": "string",
          "const": "BACKEND_NOT_FOUND"
        },
        {
          "description": "Backend did not respond within the configured timeout.",
          "type": "string",
          "const": "BACKEND_TIMEOUT"
        },
        {
          "description": "Backend process exited unexpectedly.",
          "type": "string",
          "const": "BACKEND_CRASHED"
        },
        {
          "description": "A required capability is not supported by the backend.",
          "type": "string",
          "const": "CAPABILITY_UNSUPPORTED"
        },
        {
          "description": "Capability emulation layer failed.",
          "type": "string",
          "const": "CAPABILITY_EMULATION_FAILED"
        },
        {
          "description": "A policy rule denied the operation.",
          "type": "string",
          "const": "POLICY_DENIED"
        },
        {
          "description": "Policy definition itself is malformed.",
          "type": "string",
          "const": "POLICY_INVALID"
        },
        {
          "description": "Failed to initialise the staged workspace.",
          "type": "string",
          "const": "WORKSPACE_INIT_FAILED"
        },
        {
          "description": "Failed to copy / stage files into the workspace.",
          "type": "string",
          "const": "WORKSPACE_STAGING_FAILED"
        },
        {
          "description": "IR lowering (high-level â†’ wire) failed.",
          "type": "string",
          "const": "IR_LOWERING_FAILED"
        },
        {
          "description": "IR structure is invalid or inconsistent.",
          "type": "string",
          "const": "IR_INVALID"
        },
        {
          "description": "Computed receipt hash does not match the declared hash.",
          "type": "string",
          "const": "RECEIPT_HASH_MISMATCH"
        },
        {
          "description": "Receipt chain has a gap or out-of-order entry.",
          "type": "string",
          "const": "RECEIPT_CHAIN_BROKEN"
        },
        {
          "description": "Dialect identifier is not recognised.",
          "type": "string",
          "const": "DIALECT_UNKNOWN"
        },
        {
          "description": "Mapping between dialects failed.",
          "type": "string",
          "const": "DIALECT_MAPPING_FAILED"
        },
        {
          "description": "Configuration file or value is invalid.",
          "type": "string",
          "const": "CONFIG_INVALID"
        },
        {
          "description": "Catch-all for unexpected internal errors.",
          "type": "string",
          "const": "INTERNAL"
        }
      ]
    },
    "ExecutionMode": {
      "description": "Execution mode for how ABP processes requests.\n\n- Passthrough: Lossless wrapping - ABP acts as observer/recorder only\n- Mapped: Full dialect translation - ABP translates between dialects\n\n# Examples\n\n```\nuse abp_core::ExecutionMode;\n\nlet mode = ExecutionMode::default();\nassert_eq!(mode, ExecutionMode::Mapped);\n```",
      "oneOf": [
        {
          "description": "Lossless wrapping mode. ABP passes requests directly to the SDK\nwithout modification. Stream is bitwise-equivalent to direct SDK call\nafter removing ABP framing.",
          "type": "string",
          "const": "passthrough"
        },
        {
          "description": "Full dialect translation mode. ABP translates between different\nagent dialects, potentially modifying requests and responses.",
          "type": "string",
          "const": "mapped"
        }
      ]
    },
    "Outcome": {
      "description": "High-level result status of a run.\n\n# Examples\n\n```\nuse abp_core::Outcome;\n\nlet outcome: Outcome = serde_json::from_str(r#\"\"complete\"\"#).unwrap();\nassert_eq!(outcome, Outcome::Complete);\n```",
      "oneOf": [
        {
          "description": "The run finished successfully.",
          "type": "string",
          "const": "complete"
        },
        {
          "description": "The run produced partial results (e.g. budget exhausted).",
          "type": "string",
          "const": "partial"
        },
        {
          "description": "The run failed.",
          "type": "string",
          "const": "failed"
        }
      ]
    },
    "RunMetadata": {
      "description": "Timing and identity metadata for a single run.",
      "type": "object",
      "properties": {
        "contract_version": {
          "description": "Contract version used for this run.",
          "type": "string"
        },
        "duration_ms": {
          "description": "Wall-clock duration in milliseconds.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0
        },
        "finished_at": {
          "description": "Timestamp when the run finished.",
          "type": "string",
          "format": "date-time"
        },
        "run_id": {
          "description": "Unique run identifier.",
          "type": "string",
          "format": "uuid"
        },
        "started_at": {
          "description": "Timestamp when the run started.",
          "type": "string",
          "format": "date-time"
        },
        "work_order_id": {
          "description": "The work order this run fulfilled.",
          "type": "string",
          "format": "uuid"
        }
      },
      "required": [
        "run_id",
        "work_order_id",
        "contract_version",
        "started_at",
        "finished_at",
        "duration_ms"
      ]
    },
    "SupportLevel": {
      "description": "How well a backend supports a given [`Capability`].\n\n# Examples\n\n```\nuse abp_core::{SupportLevel, MinSupport};\n\nlet native = SupportLevel::Native;\nassert!(native.satisfies(&MinSupport::Native));\nassert!(native.satisfies(&MinSupport::Emulated));\n\nlet emulated = SupportLevel::Emulated;\nassert!(!emulated.satisfies(&MinSupport::Native));\nassert!(emulated.satisfies(&MinSupport::Emulated));\n```",
      "oneOf": [
        {
          "description": "First-class support built into the backend.",
          "type": "string",
          "const": "native"
        },
        {
          "description": "Support via adapter or polyfill layer.",
          "type": "string",
          "const": "emulated"
        },
        {
          "description": "Capability is not available.",
          "type": "string",
          "const": "unsupported"
        },
        {
          "description": "Supported in principle, but disabled by policy or environment.",
          "type": "object",
          "properties": {
            "restricted": {
              "type": "object",
              "properties": {
                "reason": {
                  "description": "Human-readable explanation of the restriction.",
                  "type": "string"
                }
              },
              "required": [
                "reason"
              ]
            }
          },
          "additionalProperties": false,
          "required": [
            "restricted"
          ]
        }
      ]
    },
    "UsageNormalized": {
      "description": "Best-effort normalized token/cost counters across different backends.",
      "type": "object",
      "properties": {
        "cache_read_tokens": {
          "description": "Tokens read from the cache.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0
        },
        "cache_write_tokens": {
          "description": "Tokens written to the cache.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0
        },
        "estimated_cost_usd": {
          "description": "Estimated cost in US dollars (best-effort).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "input_tokens": {
          "description": "Number of input (prompt) tokens consumed.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0
        },
        "output_tokens": {
          "description": "Number of output (completion) tokens produced.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0
        },
        "request_units": {
          "description": "Copilot-style billing.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0
        }
      }
    },
    "VerificationReport": {
      "description": "Git-based verification data captured after a run completes.",
      "type": "object",
      "properties": {
        "git_diff": {
          "description": "Output of `git diff` in the workspace, if available.",
          "type": [
            "string",
            "null"
          ]
        },
        "git_status": {
          "description": "Output of `git status --porcelain` in the workspace, if available.",
          "type": [
            "string",
            "null"
          ]
        },
        "harness_ok": {
          "description": "Whether the harness (if any) reported success.",
          "type": "boolean"
        }
      },
      "required": [
        "harness_ok"
      ]
    }
  }
}